var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = KalmanFilterToolbox","category":"page"},{"location":"#KalmanFilterToolbox","page":"Home","title":"KalmanFilterToolbox","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for KalmanFilterToolbox.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [KalmanFilterToolbox]","category":"page"},{"location":"#KalmanFilterToolbox.IWP","page":"Home","title":"KalmanFilterToolbox.IWP","text":"IWP(wiener_process_dimension::Integer, num_derivatives::Integer)\n\nIntegrated Wiener Process.\n\nBy itself it does not have much utility right now, but together with discretize it provides discrete transition matrices that are useful for defining discrete state-space models.\n\n\n\n\n\n","category":"type"},{"location":"#KalmanFilterToolbox.discretize-Tuple{KalmanFilterToolbox.IWP, Real}","page":"Home","title":"KalmanFilterToolbox.discretize","text":"discretize(iwp::IWP, dt::Real)\n\nDiscretize the integrated Wiener process.\n\nComputes the discrete transition matrices for a time step of size dt.\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilterToolbox.ekf_update-Tuple{AbstractVector, AbstractMatrix, AbstractVector, Function, AbstractMatrix}","page":"Home","title":"KalmanFilterToolbox.ekf_update","text":"ekf_update(m, C, y, h, R)\n\nUpdate / correct the state based on a nonlinear observation.\n\nThis function does two things:\n\nit linearizes the observation function h at the mean m, with linearize, and\nit calls update to perform an update on the now-linear model.\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilterToolbox.get_backward_transition-NTuple{5, Any}","page":"Home","title":"KalmanFilterToolbox.get_backward_transition","text":"get_backward_transition(m, C, mpred, Cpred, A)\n\nCompute the affine backward transition model used for smoothing.\n\nReturns parameters for a transition x_n^S mid x_n+1^S sim mathcalN(G x_n+1^S + b Λ), computed with\n\nbeginaligned\nG = C * A^top C_p^-1 \nb = m - G m_p \nΛ = C - G C_p G^top\nendaligned\n\nTo smooth, just predict backwards.\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilterToolbox.linearize-Tuple{Function, AbstractVector}","page":"Home","title":"KalmanFilterToolbox.linearize","text":"linearize(h::Function, m::AbstractVector)\n\nLinearize the nonlinear function h at the location m.\n\nApproximate h with h(x) approx H x + b, where\n\nbeginaligned\nH = J_h(m) \nb = h(m) - H * m\nendaligned\n\nThe Jacobian is computed with automatic differentiation via ForwardDiff.jl.\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilterToolbox.preconditioned_discretize-Tuple{KalmanFilterToolbox.IWP}","page":"Home","title":"KalmanFilterToolbox.preconditioned_discretize","text":"preconditioned_discretize(iwp::IWP)\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilterToolbox.predict-Tuple{AbstractVector, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Home","title":"KalmanFilterToolbox.predict","text":"predict(m, C, A, b, Q)\n\nPredict the next state estimate for an affine Gaussian transition.\n\nGiven an affine transition model x_n+1 mid x_n sim mathcalN(x_n+1 A x_n + b Q) and a current state estimate x_n sim mathcalN (m C), predict computes the prediction estimate\n\nbeginaligned\nx_n+1 sim mathcalN (A m + b A C A^top + Q)\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilterToolbox.projectionmatrix-Tuple{KalmanFilterToolbox.IWP, Integer}","page":"Home","title":"KalmanFilterToolbox.projectionmatrix","text":"projectionmatrix(iwp::IWP, derivative::Integer)\n\nCompute the projection matrix that maps the state to the specified derivative.\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilterToolbox.smooth-Tuple{AbstractVector, AbstractMatrix, AbstractVector, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Home","title":"KalmanFilterToolbox.smooth","text":"smooth(mcurr, Ccurr, mnext, Cnext, A, Q)\n\nSmoothing step to update the \"current\" state estimate on the \"next\" one.\n\nThis implementation internally calls predict to (re-)compute the prediction estimate, and then perform the backwards smoothing.\n\nIn most cases, pre-computing the backwards transitions directly via get_backward_transition and then just predicting backwards might be the preferred strategy.\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilterToolbox.sqrt_predict-Tuple{AbstractVector, AbstractMatrix, AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Home","title":"KalmanFilterToolbox.sqrt_predict","text":"sqrt_predict(m, CL, A, b, QL)\n\nPredict the next state estimate for an affine Gaussian transition, in square-root form.\n\nIn principle, this function does the same as predict, but the covariances are given as and returned in square-root form. That is, the equivalent call to predict(m, C, A, b, Q) would be sqrt_predict(m, CL, A, b, QL), where C = CL * CL' and Q = QL * QL'.\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilterToolbox.sqrt_update-Tuple{AbstractVector, AbstractMatrix, AbstractVector, AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Home","title":"KalmanFilterToolbox.sqrt_update","text":"sqrt_update(m, CL, y, H, b, RL)\n\nUpdate / correct the state based on the affine observation, in square-root form.\n\nIn principle, this function does the same as update, but the covariances are given as and returned in square-root form. That is, the equivalent call to update(m, C, y, H, b, R) would be sqrt_update(m, CL, y, H, b, RL) where C = CL * CL' and R = RL * RL'.\n\n\n\n\n\n","category":"method"},{"location":"#KalmanFilterToolbox.update-Tuple{AbstractVector, AbstractMatrix, AbstractVector, AbstractMatrix, AbstractVector, AbstractMatrix}","page":"Home","title":"KalmanFilterToolbox.update","text":"update(m, C, y, H, b, R)\n\nUpdate / correct the state based on the affine observation.\n\nGiven a Gaussian x sim mathcalN(m C) an affine observation model\n\nbeginaligned\ny mid x sim mathcalN(y H x + b R)\nendaligned\n\nand a data point y, update computes the posterior x mid y.\n\n\n\n\n\n","category":"method"}]
}
