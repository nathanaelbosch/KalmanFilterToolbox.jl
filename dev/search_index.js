var documenterSearchIndex = {"docs":
[{"location":"filtering/#Kalman-filtering","page":"Kalman Filtering","title":"Kalman filtering","text":"","category":"section"},{"location":"filtering/","page":"Kalman Filtering","title":"Kalman Filtering","text":"Implementation of a simple Kalman filter.","category":"page"},{"location":"filtering/","page":"Kalman Filtering","title":"Kalman Filtering","text":"using LinearAlgebra, Random, GaussianDistributions, Plots, Statistics\nimport KalmanFilterToolbox as KFT\n\nts = 1:100\ndata = [sin(t / 10) .+ 0.25 .* randn(1) for t in ts]\n\nstack(x) = hcat(x...)'\n\nscatter(ts, stack(data))","category":"page"},{"location":"filtering/","page":"Kalman Filtering","title":"Kalman Filtering","text":"function filter(prior, data; dt=1 // 10)\n    d, q = prior.wiener_process_dimension, prior.num_derivatives\n    D = d * (q + 1)\n    E0 = KFT.projectionmatrix(d, q, 0)\n\n    A, Q = KFT.discretize(prior, dt)\n    b = zeros(D)\n    R, v = Matrix(0.1I, d, d), zeros(d)\n    m, C = zeros(D), Matrix(0.1I, D, D)\n\n    N = length(data)\n    xs = [Gaussian(m, C)]\n    for i in 2:N\n        m, C = KFT.predict(m, C, A, b, Q)\n        m, C = KFT.update(m, C, data[i], E0, v, R)\n        push!(xs, Gaussian(m, C))\n    end\n\n    return xs\nend\nnothing # hide","category":"page"},{"location":"filtering/","page":"Kalman Filtering","title":"Kalman Filtering","text":"d, q = 1, 2\nprior = KFT.IWP(d, q)\nxs = filter(prior, data)\n\nE0 = KFT.projectionmatrix(d, q, 0)\nms = map(x -> E0 * mean(x), xs) |> stack\nstds = map(x -> sqrt.(diag(E0 * cov(x) * E0')), xs) |> stack\nscatter(ts, stack(data), label=\"data\")\nplot!(ts, ms, ribbon=1.96 * stds, fillalpha=0.2, label=\"filter estimate\")","category":"page"},{"location":"prior_sampling/#Sampling-from-Priors","page":"Sampling from Priors","title":"Sampling from Priors","text":"","category":"section"},{"location":"prior_sampling/","page":"Sampling from Priors","title":"Sampling from Priors","text":"using LinearAlgebra, Random, GaussianDistributions, Plots\nimport KalmanFilterToolbox as KFT\n\nfunction sample(prior, T, dt; rng=MersenneTwister(42))\n    d, q = prior.wiener_process_dimension, prior.num_derivatives\n    D = d * (q + 1)\n    H = KFT.projectionmatrix(d, q, 0)\n\n    A, Q = KFT.discretize(prior, dt)\n    x = zeros(D)\n\n    N = T ÷ dt\n    ys = zeros(N, d)\n    ys[1, :] .= H * x\n    for i in 2:N\n        x = rand(rng, Gaussian(A * x, Symmetric(Q)))\n        ys[i, :] .= H * x\n    end\n\n    ts = 0:dt:T-dt\n    return ts, ys\nend\nnothing # hide","category":"page"},{"location":"prior_sampling/","page":"Sampling from Priors","title":"Sampling from Priors","text":"Common settings:","category":"page"},{"location":"prior_sampling/","page":"Sampling from Priors","title":"Sampling from Priors","text":"process_dimension = 3\nsmoothness = 1\n\nT = 100\ndt = 1 // 10\nnothing # hide","category":"page"},{"location":"prior_sampling/#Integrated-Wiener-process","page":"Sampling from Priors","title":"Integrated Wiener process","text":"","category":"section"},{"location":"prior_sampling/","page":"Sampling from Priors","title":"Sampling from Priors","text":"ts, ys = sample(KFT.IWP(process_dimension, smoothness), T, dt)\nplot(ts, ys)","category":"page"},{"location":"prior_sampling/#Integrated-Ornstein-Uhlenbeck-process","page":"Sampling from Priors","title":"Integrated Ornstein-Uhlenbeck process","text":"","category":"section"},{"location":"prior_sampling/","page":"Sampling from Priors","title":"Sampling from Priors","text":"ts, ys = sample(KFT.IOUP(process_dimension, smoothness, 10.0), T, dt)\nplot(ts, ys)","category":"page"},{"location":"prior_sampling/#Matern-process","page":"Sampling from Priors","title":"Matern process","text":"","category":"section"},{"location":"prior_sampling/","page":"Sampling from Priors","title":"Sampling from Priors","text":"ts, ys = sample(KFT.Matern(process_dimension, smoothness, 10.0), T, dt)\nplot(ts, ys)","category":"page"},{"location":"odefilter/#ODE-Filtering","page":"ODE Filtering","title":"ODE Filtering","text":"","category":"section"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"using LinearAlgebra, Random, GaussianDistributions, Plots, Statistics\nimport KalmanFilterToolbox as KFT","category":"page"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"Consider an initial value problem of the form","category":"page"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"beginaligned\ndotx(t) = f(x(t) t) qquad t in 0 T qquad x(0) = x_0\nendaligned","category":"page"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"Probabilistic ODE solver approach: Rephrase the numerical ODE solution as a state estimation problem","category":"page"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"beginaligned\nx_0 sim mathcalN left( mu_0 Sigma_0 right) \nx(t+h) mid x(t) sim mathcalN left( A(h) x(t) Q(h) right) \nz(t) mid x(t) sim mathcalN left( dotx(t_i) - f( x(t_i) ) R right) \nz(t_i) = 0 qquad i = 1 dots N \nendaligned","category":"page"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"A filter for this specific problem is implemented in the following:","category":"page"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"function odefilter(f, x0, tspan; dt=5e-1, order=3, Prior=KFT.IWP)\n    d, q = length(x0), order\n    D = d * (q + 1)\n    prior = Prior(d, q)\n    A, Q = KFT.discretize(prior, dt)\n    b = zeros(D)\n    E0, E1 = KFT.projectionmatrix(prior, 0), KFT.projectionmatrix(prior, 1)\n    h(x) = E1 * x - f(E0 * x)\n    z = zeros(d)\n    R = Matrix(1e-6I, d, d)\n\n    m = [x0 f(x0) zeros(d, q - 1)]'[:]\n    C = Diagonal([1e-6ones(d) 1e-6ones(d) ones(d, q - 1)]'[:]) |> Matrix\n\n    t = tspan[1]\n    ts, xs = [t], [E0 * Gaussian(m, C)]\n    while t <= tspan[2]\n        t += dt\n        m, C = KFT.predict(m, C, A, b, Q)\n        m, C = KFT.ekf_update(m, C, z, h, R)\n        push!(ts, t)\n        push!(xs, E0 * Gaussian(m, C))\n    end\n    return ts, xs\nend\nnothing # hide","category":"page"},{"location":"odefilter/#Example:-Logistic-equation","page":"ODE Filtering","title":"Example: Logistic equation","text":"","category":"section"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"Consider the logistic initial value problem","category":"page"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"beginaligned\ndotx(t) = x(t) cdot left( 1 - x(t) right) qquad t in 0 10 qquad\nx(0) = 002\nendaligned","category":"page"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"Running the ODE filter for this problem:","category":"page"},{"location":"odefilter/","page":"ODE Filtering","title":"ODE Filtering","text":"f(x) = @. x * (1 - x)\nx0 = [0.02]\ntspan = (0.0, 10.0)\n\nts, xs = odefilter(f, x0, tspan)\nstack(x) = hcat(x...)'\nms = stack(mean.(xs))\nCs = stack(map(x -> diag(cov(x)), xs))\nplot(ts, ms, ribbon=1.96sqrt.(Cs), marker=:o, markersize=2, markerstrokewidth=0.1)","category":"page"},{"location":"priors/#Gauss-Markov-Processes","page":"Gauss-Markov Processes","title":"Gauss-Markov Processes","text":"","category":"section"},{"location":"priors/","page":"Gauss-Markov Processes","title":"Gauss-Markov Processes","text":"Things that relate to continuous-time Gauss-Markov processes and their discretization.","category":"page"},{"location":"priors/","page":"Gauss-Markov Processes","title":"Gauss-Markov Processes","text":"CurrentModule = KalmanFilterToolbox","category":"page"},{"location":"priors/#Processes","page":"Gauss-Markov Processes","title":"Processes","text":"","category":"section"},{"location":"priors/","page":"Gauss-Markov Processes","title":"Gauss-Markov Processes","text":"IWP\nIOUP\nMatern","category":"page"},{"location":"priors/#KalmanFilterToolbox.IWP","page":"Gauss-Markov Processes","title":"KalmanFilterToolbox.IWP","text":"IWP(wiener_process_dimension::Integer, num_derivatives::Integer)\n\nIntegrated Wiener process.\n\nBy itself it does not have much utility right now, but together with discretize it provides discrete transition matrices that are useful for defining discrete state-space models.\n\n\n\n\n\n","category":"type"},{"location":"priors/#KalmanFilterToolbox.IOUP","page":"Gauss-Markov Processes","title":"KalmanFilterToolbox.IOUP","text":"IOUP(wiener_process_dimension::Integer, num_derivatives::Integer, drift_speed::Real)\n\nIntegrated Ornstein-Uhlenbeck process.\n\n\n\n\n\n","category":"type"},{"location":"priors/#KalmanFilterToolbox.Matern","page":"Gauss-Markov Processes","title":"KalmanFilterToolbox.Matern","text":"Matern(wiener_process_dimension::Integer, num_derivatives::Integer, lengthscale::Real)\n\nMatern process. Typically, they are defined with a half-integer parameter ν. To get the corresponding process here, set num_derivatives = ν+1/2.\n\n\n\n\n\n","category":"type"},{"location":"priors/#Utilities","page":"Gauss-Markov Processes","title":"Utilities","text":"","category":"section"},{"location":"priors/","page":"Gauss-Markov Processes","title":"Gauss-Markov Processes","text":"discretize\nprojectionmatrix\npreconditioner\nmatrix_fraction_decomposition\npreconditioned_discretize","category":"page"},{"location":"priors/#KalmanFilterToolbox.discretize","page":"Gauss-Markov Processes","title":"KalmanFilterToolbox.discretize","text":"discretize(p::AbstractGaussMarkovProcess, dt::Real)\n\nDiscretize the Gauss-Markov process.\n\nComputes the discrete transition matrices for a time step of size dt.\n\n\n\n\n\ndiscretize(sde::LTISDE, dt::Real)\n\nCompute the discrete transition via the matrix fraction decomposition.\n\nSee also: matrix_fraction_decomposition\n\n\n\n\n\n","category":"function"},{"location":"priors/#KalmanFilterToolbox.projectionmatrix","page":"Gauss-Markov Processes","title":"KalmanFilterToolbox.projectionmatrix","text":"projectionmatrix(process::AbstractGaussMarkovProcess, derivative::Integer)\n\nCompute the projection matrix that maps the state to the specified derivative.\n\n\n\n\n\n","category":"function"},{"location":"priors/#KalmanFilterToolbox.preconditioner","page":"Gauss-Markov Processes","title":"KalmanFilterToolbox.preconditioner","text":"preconditioner(p::AbstractGaussMarkovProcess, dt::Real)\n\nComputes a preconditioner, which is helpful for numerically stable implementation.\n\nThis corresponds to the preconditioner as described by [1], developed for integrated Wiener process priors (IWP), but it might also be useful for other priors.\n\n[1] Krämer & Hennig, \"Stable Implementation of Probabilistic ODE Solvers\", 2020.\n\n\n\n\n\n","category":"function"},{"location":"priors/#KalmanFilterToolbox.matrix_fraction_decomposition","page":"Gauss-Markov Processes","title":"KalmanFilterToolbox.matrix_fraction_decomposition","text":"matrix_fraction_decomposition(drift::AbstractMatrix, dispersion::AbstractVecOrMat, dt::Real)\n\n\n\n\n\n","category":"function"},{"location":"priors/#KalmanFilterToolbox.preconditioned_discretize","page":"Gauss-Markov Processes","title":"KalmanFilterToolbox.preconditioned_discretize","text":"preconditioned_discretize(p::IWP)\n\nPreconditioned discretization of the integrated Wiener process.\n\nFor the IWP, the preconditioned discretization is independend of the current step size and known in closed form. This is very helpful for numerically stable implementations and high efficiency.\n\n\n\n\n\n","category":"function"},{"location":"priors/#SDE-and-tools","page":"Gauss-Markov Processes","title":"SDE and tools","text":"","category":"section"},{"location":"priors/","page":"Gauss-Markov Processes","title":"Gauss-Markov Processes","text":"LTISDE\nto_1d_sde","category":"page"},{"location":"priors/#KalmanFilterToolbox.LTISDE","page":"Gauss-Markov Processes","title":"KalmanFilterToolbox.LTISDE","text":"LTISDE(drift::AbstractMatrix, dispersion::AbstractVecOrMat)\n\nLinear time-invariant SDE\n\nbeginaligned\ndx = F x dt + L dβ\nendaligned\n\nwith drift F and dispersion L, and diffusion σ.\n\n\n\n\n\n","category":"type"},{"location":"priors/#KalmanFilterToolbox.to_1d_sde","page":"Gauss-Markov Processes","title":"KalmanFilterToolbox.to_1d_sde","text":"to_1d_sde(p::AbstractGaussMarkovProcess)\n\nBuild a LTISDE that corresponds to a single dimension of the given Gauss-Markov process.\n\nJust working on a single dimension leads to more efficient code, so that the full matrices can be built at the very end (e.g. after computing the one-dimensional transition matrices via matrix fraction decomposition) with a Kronecker product.\n\n\n\n\n\n","category":"function"},{"location":"filtsmooth/#Filtering-and-Smoothing","page":"Filtering and Smoothing","title":"Filtering and Smoothing","text":"","category":"section"},{"location":"filtsmooth/","page":"Filtering and Smoothing","title":"Filtering and Smoothing","text":"predict / update / smooth functions and more.","category":"page"},{"location":"filtsmooth/","page":"Filtering and Smoothing","title":"Filtering and Smoothing","text":"CurrentModule = KalmanFilterToolbox","category":"page"},{"location":"filtsmooth/","page":"Filtering and Smoothing","title":"Filtering and Smoothing","text":"predict\nsqrt_predict\nupdate\nsqrt_update\nsmooth\nget_backward_transition","category":"page"},{"location":"filtsmooth/#KalmanFilterToolbox.predict","page":"Filtering and Smoothing","title":"KalmanFilterToolbox.predict","text":"predict(m, C, A, b, Q)\n\nPredict the next state estimate for an affine Gaussian transition.\n\nGiven an affine transition model x_n+1 mid x_n sim mathcalN(x_n+1 A x_n + b Q) and a current state estimate x_n sim mathcalN (m C), predict computes the prediction estimate\n\nbeginaligned\nx_n+1 sim mathcalN (A m + b A C A^top + Q)\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"filtsmooth/#KalmanFilterToolbox.sqrt_predict","page":"Filtering and Smoothing","title":"KalmanFilterToolbox.sqrt_predict","text":"sqrt_predict(m, CL, A, b, QL)\n\nPredict the next state estimate for an affine Gaussian transition, in square-root form.\n\nIn principle, this function does the same as predict, but the covariances are given as and returned in square-root form. That is, the equivalent call to predict(m, C, A, b, Q) would be sqrt_predict(m, CL, A, b, QL), where C = CL * CL' and Q = QL * QL'.\n\n\n\n\n\n","category":"function"},{"location":"filtsmooth/#KalmanFilterToolbox.update","page":"Filtering and Smoothing","title":"KalmanFilterToolbox.update","text":"update(m, C, y, H, b, R)\n\nUpdate / correct the state based on the affine observation.\n\nGiven a Gaussian x sim mathcalN(m C) an affine observation model\n\nbeginaligned\ny mid x sim mathcalN(y H x + b R)\nendaligned\n\nand a data point y, update computes the posterior x mid y.\n\n\n\n\n\n","category":"function"},{"location":"filtsmooth/#KalmanFilterToolbox.sqrt_update","page":"Filtering and Smoothing","title":"KalmanFilterToolbox.sqrt_update","text":"sqrt_update(m, CL, y, H, b, RL)\n\nUpdate / correct the state based on the affine observation, in square-root form.\n\nIn principle, this function does the same as update, but the covariances are given as and returned in square-root form. That is, the equivalent call to update(m, C, y, H, b, R) would be sqrt_update(m, CL, y, H, b, RL) where C = CL * CL' and R = RL * RL'.\n\n\n\n\n\n","category":"function"},{"location":"filtsmooth/#KalmanFilterToolbox.smooth","page":"Filtering and Smoothing","title":"KalmanFilterToolbox.smooth","text":"smooth(mcurr, Ccurr, mnext, Cnext, A, Q)\n\nSmoothing step to update the \"current\" state estimate on the \"next\" one.\n\nThis implementation internally calls predict to (re-)compute the prediction estimate, and then perform the backwards smoothing.\n\nIn most cases, pre-computing the backwards transitions directly via get_backward_transition and then just predicting backwards might be the preferred strategy.\n\n\n\n\n\n","category":"function"},{"location":"filtsmooth/#KalmanFilterToolbox.get_backward_transition","page":"Filtering and Smoothing","title":"KalmanFilterToolbox.get_backward_transition","text":"get_backward_transition(m, C, mpred, Cpred, A)\n\nCompute the affine backward transition model used for smoothing.\n\nReturns parameters for a transition x_n^S mid x_n+1^S sim mathcalN(G x_n+1^S + b Λ), computed with\n\nbeginaligned\nG = C * A^top C_p^-1 \nb = m - G m_p \nΛ = C - G C_p G^top\nendaligned\n\nTo smooth, just predict backwards.\n\n\n\n\n\n","category":"function"},{"location":"filtsmooth/#Approximate-inference-via-linearization","page":"Filtering and Smoothing","title":"Approximate inference via linearization","text":"","category":"section"},{"location":"filtsmooth/","page":"Filtering and Smoothing","title":"Filtering and Smoothing","text":"linearize\nekf_update","category":"page"},{"location":"filtsmooth/#KalmanFilterToolbox.linearize","page":"Filtering and Smoothing","title":"KalmanFilterToolbox.linearize","text":"linearize(h::Function, m::AbstractVector)\n\nLinearize the nonlinear function h at the location m.\n\nApproximate h with h(x) approx H x + b, where\n\nbeginaligned\nH = J_h(m) \nb = h(m) - H * m\nendaligned\n\nThe Jacobian is computed with automatic differentiation via ForwardDiff.jl.\n\n\n\n\n\n","category":"function"},{"location":"filtsmooth/#KalmanFilterToolbox.ekf_update","page":"Filtering and Smoothing","title":"KalmanFilterToolbox.ekf_update","text":"ekf_update(m, C, y, h, R)\n\nUpdate / correct the state based on a nonlinear observation.\n\nThis function does two things:\n\nit linearizes the observation function h at the mean m, with linearize, and\nit calls update to perform an update on the now-linear model.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = KalmanFilterToolbox","category":"page"},{"location":"#KalmanFilterToolbox.jl","page":"Home","title":"KalmanFilterToolbox.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Handy code for the Gaussian filtering and smoothing aficionado.","category":"page"},{"location":"#API-documentation:","page":"Home","title":"API documentation:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"filtsmooth.md\", \"priors.md\"]\nDepth = 2","category":"page"},{"location":"#Examples:","page":"Home","title":"Examples:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"prior_sampling.md\"]\nDepth = 1","category":"page"},{"location":"#See-also","page":"Home","title":"See also","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MarkovKernels.jl","category":"page"}]
}
